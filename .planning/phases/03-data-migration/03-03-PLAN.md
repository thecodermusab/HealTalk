---
phase: 03-data-migration
plan: 03
type: execute
depends_on: ["03-02"]
files_modified: [prisma/schema.prisma, prisma/seeds/blog.ts, prisma/seeds/guides.ts, prisma/seeds/podcasts.ts, src/app/api/blog/route.ts, src/app/api/blog/[id]/route.ts, src/app/api/guides/route.ts, src/app/api/podcasts/route.ts]
---

<objective>
Create database models and seeding scripts for blog posts, guides, and podcast content. Migrate content data from TypeScript mock files to PostgreSQL.

Purpose: Enable dynamic content management for blog, guides, and podcasts with searchable, filterable database queries instead of static imports.

Output: Database models, seeding infrastructure, and API routes for all content types.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-data-migration/03-02-SUMMARY.md
@prisma/schema.prisma
@src/lib/mock-blog-data.ts
@src/lib/mock-guides-data.ts
@src/lib/mock-podcast-data.ts

**Prerequisites:**
- Database running with psychologist data (from Plans 03-01, 03-02)
- Prisma Client generated and available
- Seed script infrastructure exists

**Current mock data:**
- Blog: 15 posts with authors, content blocks (377 lines)
  - Complex structure: BlogPost → Author, BlogPostContent[]
  - First 3 posts have full content, rest are placeholders
  - Author can be string or Author object
- Guides: 12 guides with simple metadata (94 lines)
- Podcasts: 12 episodes with links (94 lines)

**Target implementation:**
- Database models for BlogPost, BlogAuthor, BlogContent, Guide, PodcastEpisode
- Seeding scripts that transform mock data structure
- API routes for listing and individual content items
- Support for filtering, pagination, and search
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add content models to Prisma schema</name>
  <files>prisma/schema.prisma</files>
  <action>
Add Blog, Guide, and Podcast models to the end of `prisma/schema.prisma`.

```prisma
// Blog models
model BlogPost {
  id              String   @id @default(cuid())
  title           String
  subtitle        String?
  excerpt         String   @db.Text
  imageUrl        String
  category        String?
  date            DateTime
  heroType        String?  // 'illustration' | 'photo'
  heroIllustration String?
  theme           String?  // 'lilac' | 'green' | 'cream'
  published       Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  authorId        String?
  author          BlogAuthor? @relation(fields: [authorId], references: [id])
  content         BlogContent[]
}

model BlogAuthor {
  id            String   @id @default(cuid())
  name          String   @unique
  role          String
  bio           String   @db.Text
  imageUrl      String
  linkedinUrl   String
  socialLabel   String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  posts         BlogPost[]
}

model BlogContent {
  id            String   @id @default(cuid())
  blogPostId    String
  order         Int      // To maintain content order
  type          String   // 'paragraph' | 'heading' | 'list' | 'quote'
  value         String   @db.Text // Store as JSON string for arrays

  blogPost      BlogPost @relation(fields: [blogPostId], references: [id], onDelete: Cascade)

  @@index([blogPostId, order])
}

// Guide model
model Guide {
  id          String   @id @default(cuid())
  title       String
  coverTitle  String?
  theme       String   // 'lavender' | 'green' | 'cream' | 'blue'
  href        String   @unique
  published   Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// Podcast model
model PodcastEpisode {
  id              String   @id @default(cuid())
  episodeNumber   String
  title           String
  spotifyUrl      String
  youtubeUrl      String
  published       Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}
```

Important:
- BlogContent has order field to maintain sequence
- BlogAuthor.name is unique (one author, many posts)
- Guide.href is unique (routing)
- All models have published flag for draft management
- BlogContent.value stores arrays as JSON string
  </action>
  <verify>
```bash
# Generate Prisma Client with new models
npx prisma generate

# Create and apply migration
npx prisma migrate dev --name add_content_models

# Verify models created
npx prisma db pull --print
```
  </verify>
  <done>
- BlogPost, BlogAuthor, BlogContent models added to schema
- Guide model added to schema
- PodcastEpisode model added to schema
- Prisma migration created and applied
- Prisma Client regenerated with new models
  </done>
</task>

<task type="auto">
  <name>Task 2: Create blog seeding data</name>
  <files>prisma/seeds/blog.ts</files>
  <action>
Create `prisma/seeds/blog.ts` that transforms mock blog data for database seeding.

```typescript
import { BLOG_POSTS } from '../../src/lib/mock-blog-data';

// Extract unique authors from blog posts
export const blogAuthorSeedData = [
  {
    name: "Musab Mohamed Ali",
    role: "CEO / Partner",
    bio: "Musab Mohamed Ali is the CEO and Partner at HealTalk, dedicated to making mental health support accessible and stigma-free for everyone.",
    imageUrl: "/images/Me.png",
    linkedinUrl: "https://www.instagram.com/maahir.03?igsh=anY3cXUzanhwNTNj&utm_source=qr",
    socialLabel: "Instagram"
  },
  {
    name: "Radia Ahmed Abdirahman",
    role: "Head of Care Operations",
    bio: "Radia Ahmed is a licensed therapist specializing in depression, family dynamics, and relationship counseling.",
    imageUrl: "/images/ciro.png",
    linkedinUrl: "#"
  },
  {
    name: "Ugbad Bashir Barre",
    role: "Client Director",
    bio: "Ugbaad is a mental health counselor focused on stress management, work-life balance, and building emotional resilience.",
    imageUrl: "/images/Mustaf.png",
    linkedinUrl: "#"
  },
  {
    name: "Sabirin Ali Isack",
    role: "Director of Operations",
    bio: "Sabiriin is a mental health professional specializing in holistic wellness and community mental health.",
    imageUrl: "/images/koonfur.png",
    linkedinUrl: "#"
  },
  {
    name: "Abdulkadir Mohamed Abdi",
    role: "Head of People",
    bio: "Abdulkadir is a mental health advocate focused on organizational wellness and employee mental health.",
    imageUrl: "/images/koonfur.png",
    linkedinUrl: "#"
  }
];

export const blogPostSeedData = BLOG_POSTS.map(post => {
  // Handle author - can be string or object
  const authorName = typeof post.author === 'string'
    ? post.author
    : post.author.name;

  // Parse date to DateTime
  const date = new Date(post.date);

  return {
    title: post.title,
    subtitle: post.subtitle,
    excerpt: post.excerpt,
    imageUrl: post.imageUrl,
    category: post.category || 'Mental Health',
    date: date,
    heroType: post.heroType || 'photo',
    heroIllustration: post.heroIllustration,
    theme: post.theme || 'green',
    published: true,
    authorName: authorName, // Will be resolved to authorId
    content: post.content || [] // BlogPostContent array
  };
});
```

Important:
- Extract unique authors first (5 total)
- Transform author string|object to authorName string
- Parse date strings to Date objects
- Default category to 'Mental Health'
- Default heroType to 'photo'
- Keep content array for later processing
- All posts published by default
  </action>
  <verify>
```bash
# File exists and exports data
cat prisma/seeds/blog.ts | grep "export const blogAuthorSeedData"
cat prisma/seeds/blog.ts | grep "export const blogPostSeedData"

# Valid TypeScript
npx tsc --noEmit prisma/seeds/blog.ts

# Count posts (should be 15)
node -e "const {blogPostSeedData} = require('./prisma/seeds/blog.ts'); console.log('Posts:', blogPostSeedData.length);"
```
  </verify>
  <done>
- prisma/seeds/blog.ts created
- Exports blogAuthorSeedData (5 authors)
- Exports blogPostSeedData (15 posts)
- Transforms author references to names
- Parses dates correctly
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Create guides and podcasts seeding data</name>
  <files>prisma/seeds/guides.ts, prisma/seeds/podcasts.ts</files>
  <action>
Create `prisma/seeds/guides.ts`:

```typescript
import { GUIDES } from '../../src/lib/mock-guides-data';

export const guideSeedData = GUIDES.map(guide => ({
  title: guide.title,
  coverTitle: guide.coverTitle || guide.title,
  theme: guide.theme,
  href: guide.href,
  published: true
}));
```

Create `prisma/seeds/podcasts.ts`:

```typescript
import { PODCAST_EPISODES } from '../../src/lib/mock-podcast-data';

export const podcastSeedData = PODCAST_EPISODES.map(episode => ({
  episodeNumber: episode.episodeNumber,
  title: episode.title,
  spotifyUrl: episode.spotifyUrl,
  youtubeUrl: episode.youtubeUrl,
  published: true
}));
```

Important:
- Guides: Default coverTitle to title if not provided
- Both seed all items as published
- Simple 1:1 mapping from mock data
  </action>
  <verify>
```bash
# Files exist and export data
cat prisma/seeds/guides.ts | grep "export const guideSeedData"
cat prisma/seeds/podcasts.ts | grep "export const podcastSeedData"

# Valid TypeScript
npx tsc --noEmit prisma/seeds/guides.ts
npx tsc --noEmit prisma/seeds/podcasts.ts

# Count items (12 guides, 12 podcasts)
node -e "const {guideSeedData} = require('./prisma/seeds/guides.ts'); console.log('Guides:', guideSeedData.length);"
node -e "const {podcastSeedData} = require('./prisma/seeds/podcasts.ts'); console.log('Podcasts:', podcastSeedData.length);"
```
  </verify>
  <done>
- prisma/seeds/guides.ts created with 12 guides
- prisma/seeds/podcasts.ts created with 12 podcasts
- Simple transformations applied
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 4: Update seed script for content data</name>
  <files>prisma/seed.ts</files>
  <action>
Update `prisma/seed.ts` to import and seed blog, guides, and podcasts after the psychologist seeding section.

Add imports at top:
```typescript
import { blogAuthorSeedData, blogPostSeedData } from './seeds/blog';
import { guideSeedData } from './seeds/guides';
import { podcastSeedData } from './seeds/podcasts';
```

Add after psychologist seeding:
```typescript
console.log('Seeding blog authors...');
const authorMap = new Map();
for (const a of blogAuthorSeedData) {
  const author = await prisma.blogAuthor.upsert({
    where: { name: a.name },
    update: {},
    create: a
  });
  authorMap.set(a.name, author.id);
  console.log(`  ✓ ${a.name}`);
}

console.log('Seeding blog posts...');
for (const post of blogPostSeedData) {
  const authorId = authorMap.get(post.authorName);

  const blogPost = await prisma.blogPost.create({
    data: {
      title: post.title,
      subtitle: post.subtitle,
      excerpt: post.excerpt,
      imageUrl: post.imageUrl,
      category: post.category,
      date: post.date,
      heroType: post.heroType,
      heroIllustration: post.heroIllustration,
      theme: post.theme,
      published: post.published,
      authorId: authorId,
      content: {
        create: post.content.map((c: any, index: number) => ({
          order: index,
          type: c.type,
          value: Array.isArray(c.value) ? JSON.stringify(c.value) : c.value
        }))
      }
    }
  });
  console.log(`  ✓ ${post.title}`);
}

console.log('Seeding guides...');
for (const guide of guideSeedData) {
  await prisma.guide.upsert({
    where: { href: guide.href },
    update: {},
    create: guide
  });
  console.log(`  ✓ ${guide.title}`);
}

console.log('Seeding podcast episodes...');
for (const episode of podcastSeedData) {
  await prisma.podcastEpisode.create({
    data: episode
  });
  console.log(`  ✓ Episode ${episode.episodeNumber}: ${episode.title}`);
}

console.log('✓ All content seeded successfully!');
```

Important:
- Upsert authors by name (idempotent)
- Create blog posts with nested content creation
- Map authorName to authorId using authorMap
- BlogContent.value: JSON.stringify() for arrays, direct for strings
- BlogContent.order maintains sequence
- Upsert guides by href
- Create podcasts (no unique constraint, fresh each time)
  </action>
  <verify>
```bash
# Seed script compiles
npx tsc --noEmit prisma/seed.ts

# Run seed (should not error)
npm run db:seed

# Verify content created
node -e "const { PrismaClient } = require('@prisma/client'); const prisma = new PrismaClient(); Promise.all([prisma.blogPost.count(), prisma.guide.count(), prisma.podcastEpisode.count()]).then(([b,g,p]) => console.log('Blog posts:', b, '| Guides:', g, '| Podcasts:', p)).finally(() => prisma.\$disconnect());"
```
  </verify>
  <done>
- prisma/seed.ts updated with content seeding
- Imports from ./seeds/blog, ./seeds/guides, ./seeds/podcasts
- npm run db:seed completes without errors
- Database has 15 blog posts with authors and content
- Database has 12 guides
- Database has 12 podcast episodes
- Idempotent for authors and guides
  </done>
</task>

<task type="auto">
  <name>Task 5: Create blog API routes</name>
  <files>src/app/api/blog/route.ts, src/app/api/blog/[id]/route.ts</files>
  <action>
Create `src/app/api/blog/route.ts` with GET endpoint for listing blog posts:

```typescript
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const category = searchParams.get('category') || '';
    const search = searchParams.get('search') || '';
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '12');

    const where: any = {
      published: true,
    };

    // Filter by category
    if (category) {
      where.category = category;
    }

    // Search by title or excerpt
    if (search) {
      where.OR = [
        { title: { contains: search, mode: 'insensitive' } },
        { excerpt: { contains: search, mode: 'insensitive' } },
      ];
    }

    const [posts, total] = await Promise.all([
      prisma.blogPost.findMany({
        where,
        include: {
          author: {
            select: {
              name: true,
              role: true,
              imageUrl: true,
            },
          },
        },
        orderBy: { date: 'desc' },
        skip: (page - 1) * limit,
        take: limit,
      }),
      prisma.blogPost.count({ where }),
    ]);

    return NextResponse.json({
      posts,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (error) {
    console.error('Error fetching blog posts:', error);
    return NextResponse.json(
      { error: 'Failed to fetch blog posts' },
      { status: 500 }
    );
  }
}
```

Create `src/app/api/blog/[id]/route.ts` for individual blog posts:

```typescript
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const post = await prisma.blogPost.findUnique({
      where: { id: params.id },
      include: {
        author: true,
        content: {
          orderBy: { order: 'asc' },
        },
      },
    });

    if (!post) {
      return NextResponse.json(
        { error: 'Blog post not found' },
        { status: 404 }
      );
    }

    if (!post.published) {
      return NextResponse.json(
        { error: 'Blog post not available' },
        { status: 403 }
      );
    }

    // Transform content back to original format
    const transformedPost = {
      ...post,
      content: post.content.map(c => ({
        type: c.type,
        value: c.type === 'list' ? JSON.parse(c.value) : c.value
      }))
    };

    return NextResponse.json(transformedPost);
  } catch (error) {
    console.error('Error fetching blog post:', error);
    return NextResponse.json(
      { error: 'Failed to fetch blog post' },
      { status: 500 }
    );
  }
}
```

Important:
- List route: Filter by category, search title/excerpt, pagination
- List route: Order by date DESC (newest first)
- List route: Only return published posts
- Detail route: Include full author and ordered content
- Detail route: Transform JSON arrays back from strings
- Detail route: 403 if unpublished, 404 if not found
  </action>
  <verify>
```bash
# Test blog listing
curl http://localhost:3000/api/blog | jq '.posts | length'

# Test with category filter
curl "http://localhost:3000/api/blog?category=Mental%20Health" | jq '.posts | length'

# Test with search
curl "http://localhost:3000/api/blog?search=therapy" | jq '.posts[0].title'

# Test individual post
BLOG_ID=$(curl -s http://localhost:3000/api/blog | jq -r '.posts[0].id')
curl "http://localhost:3000/api/blog/${BLOG_ID}" | jq '.title, .author.name, (.content | length)'
```
  </verify>
  <done>
- /api/blog GET endpoint created with filtering
- /api/blog/[id] GET endpoint created
- Supports category filter, search, pagination
- Only returns published posts
- Returns posts with author info
- Content properly transformed with order preserved
  </done>
</task>

<task type="auto">
  <name>Task 6: Create guides and podcasts API routes</name>
  <files>src/app/api/guides/route.ts, src/app/api/podcasts/route.ts</files>
  <action>
Create `src/app/api/guides/route.ts`:

```typescript
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const theme = searchParams.get('theme') || '';
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '12');

    const where: any = {
      published: true,
    };

    if (theme) {
      where.theme = theme;
    }

    const [guides, total] = await Promise.all([
      prisma.guide.findMany({
        where,
        orderBy: { createdAt: 'desc' },
        skip: (page - 1) * limit,
        take: limit,
      }),
      prisma.guide.count({ where }),
    ]);

    return NextResponse.json({
      guides,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (error) {
    console.error('Error fetching guides:', error);
    return NextResponse.json(
      { error: 'Failed to fetch guides' },
      { status: 500 }
    );
  }
}
```

Create `src/app/api/podcasts/route.ts`:

```typescript
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '12');

    const where = {
      published: true,
    };

    const [episodes, total] = await Promise.all([
      prisma.podcastEpisode.findMany({
        where,
        orderBy: { episodeNumber: 'asc' },
        skip: (page - 1) * limit,
        take: limit,
      }),
      prisma.podcastEpisode.count({ where }),
    ]);

    return NextResponse.json({
      episodes,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (error) {
    console.error('Error fetching podcast episodes:', error);
    return NextResponse.json(
      { error: 'Failed to fetch podcast episodes' },
      { status: 500 }
    );
  }
}
```

Important:
- Guides: Filter by theme, pagination
- Guides: Order by createdAt DESC
- Podcasts: No filters (simple listing)
- Podcasts: Order by episodeNumber ASC
- Both: Only return published items
- Both: Include pagination metadata
  </action>
  <verify>
```bash
# Test guides listing
curl http://localhost:3000/api/guides | jq '.guides | length'

# Test guides theme filter
curl "http://localhost:3000/api/guides?theme=lavender" | jq '.guides | length'

# Test podcasts listing
curl http://localhost:3000/api/podcasts | jq '.episodes | length'

# Check ordering
curl http://localhost:3000/api/podcasts | jq '.episodes[0].episodeNumber'
```
  </verify>
  <done>
- /api/guides GET endpoint created
- /api/podcasts GET endpoint created
- Guides support theme filtering
- Podcasts ordered by episode number
- Pagination working for both
- Only published items returned
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Prisma schema has BlogPost, BlogAuthor, BlogContent, Guide, PodcastEpisode models
- [ ] Migration created and applied successfully
- [ ] Seed files created: blog.ts, guides.ts, podcasts.ts
- [ ] npm run db:seed populates all content
- [ ] Database has 15 blog posts with content and authors
- [ ] Database has 12 guides
- [ ] Database has 12 podcast episodes
- [ ] /api/blog endpoint returns posts with filters
- [ ] /api/blog/[id] endpoint returns single post with content
- [ ] /api/guides endpoint returns guides
- [ ] /api/podcasts endpoint returns episodes
- [ ] npm run build succeeds
</verification>

<success_criteria>

- Content models added to Prisma schema
- Seeding scripts transform all mock content data
- All content populated in database
- API routes created for blog, guides, podcasts
- Filtering and pagination working
- Content properly structured with relations
- Ready for page updates (Plan 03-04)
</success_criteria>

<output>
After completion, create `.planning/phases/03-data-migration/03-03-SUMMARY.md`:

# Phase 3 Plan 3: Blog, Guides, and Podcasts Data Migration Summary

**Blog, guides, and podcast content now stored in PostgreSQL with API routes**

## Accomplishments

- Added 5 new models to Prisma schema (BlogPost, BlogAuthor, BlogContent, Guide, PodcastEpisode)
- Created seeding scripts for all content types
- Migrated 15 blog posts with nested content and authors
- Migrated 12 guides and 12 podcast episodes
- Created API routes with filtering and pagination
- All content accessible via database queries

## Files Created/Modified

- `prisma/schema.prisma` - Added content models
- `prisma/seeds/blog.ts` - Blog authors and posts seed data
- `prisma/seeds/guides.ts` - Guide seed data
- `prisma/seeds/podcasts.ts` - Podcast episode seed data
- `prisma/seed.ts` - Updated to seed all content
- `src/app/api/blog/route.ts` - Blog listing endpoint
- `src/app/api/blog/[id]/route.ts` - Individual blog post endpoint
- `src/app/api/guides/route.ts` - Guides listing endpoint
- `src/app/api/podcasts/route.ts` - Podcasts listing endpoint

## Data Transformation

**Blog structure:**
- Normalized authors to separate BlogAuthor table
- Blog content stored as ordered BlogContent records
- Array values (lists) stored as JSON strings
- Date strings parsed to DateTime

**Guides & Podcasts:**
- Simple 1:1 mapping from mock data
- All items published by default

## API Features

**Blog API:**
- Filter by category
- Search title/excerpt (case-insensitive)
- Pagination support
- Returns posts with author info
- Individual posts include ordered content blocks

**Guides API:**
- Filter by theme
- Pagination support

**Podcasts API:**
- Simple listing with pagination
- Ordered by episode number

## Decisions Made

- Separated blog authors into own table (normalized)
- Blog content stored as separate records with order field
- All content has published flag for draft management
- Used upsert for authors and guides (idempotent)
- Podcasts recreated on each seed (no unique constraint)

## Issues Encountered

[Any issues or "None"]

## Next Step

Ready for **03-04-PLAN.md** - Remove mock data files and verify all pages work with database
</output>
